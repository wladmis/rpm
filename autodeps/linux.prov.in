#!/bin/sh -ef
#
# Copyright (C) 2000-2004  Dmitry V. Levin <ldv@altlinux.org>
# $Id$
#
# find-provides - generate list of linux-specific package provides.
# Inspired by tool with same name from RPM distribution.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

[ -z "$RPM_SCRIPTS_DEBUG" ] || set -x

PROG="${0##*/}"

# If using normal root, avoid changing anything.
if [ -z "$(printf %s "$RPM_BUILD_ROOT" |tr -d ' /.')" ]; then
	echo "$PROG: non-/ RPM_BUILD_ROOT expected" >&2
	exit 1
fi

# Normalize buildroot.
real_buildroot=$(readlink -fv "$RPM_BUILD_ROOT") || exit 1

FIND_LIBS=
FIND_PAM=
FIND_PERL=
FIND_SHELL=

ParseMethod()
{
	local t
	for	t in "$@"; do
		case "${t/%,}" in
			no|none|off|false)
				FIND_LIBS=
				FIND_PAM=
				FIND_PERL=
				FIND_SHELL=
				;;
			lib)
				FIND_LIBS=1
				;;
			nolib)
				FIND_LIBS=
				;;
			pam)
				FIND_PAM=1
				;;
			nopam)
				FIND_PAM=
				;;
			perl)
				FIND_PERL=1
				;;
			noperl)
				FIND_PERL=
				;;
			sh|shell)
				FIND_SHELL=1
				;;
			nosh|noshell)
				FIND_SHELL=
				;;
			all)
				FIND_LIBS=1
				FIND_PAM=1
				FIND_PERL=1
				FIND_SHELL=1
				;;
			default|yes|true)
				ParseMethod $RPM_FINDPROV_DEFAULT_METHOD || return 1
				;;
			*)
				echo "Unrecognized find-provides method: $t" >&2
				exit 1
				;;
		esac
	done
}
ParseMethod $RPM_FINDPROV_METHOD

if [ -z "$FIND_LIBS" -a -z "$FIND_PAM" -a -z "$FIND_PERL" -a -z "$FIND_SHELL" ]; then
	# Nothing to do
	cat >/dev/null 2>&1
	exit 0
fi

ulimit -c 0

case "$LD_PRELOAD" in
	*libfakeroot*)
		unset LD_PRELOAD
		;;
	*libbuildreq.so*)
		unset LD_PRELOAD
		;;
esac

FOUND_PROVS=
LIST_PERL=

ListScriptProvs()
{
	local f t
	f="$1"
	t="$2"

	if [ -z "${t##ASCII *text*}" ]; then
		if [ -z "${f%%$RPM_BUILD_ROOT/etc/pam.d/*}" ]; then
			if [ -n "$FIND_PAM" ]; then
				local r
				r="$(@RPMCONFIGDIR@/pam.prov "$f")" || return 1
				[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
			fi
			return 0
		fi

		# Ignore symlinks for non-PAM scripts.
		[ ! -L "$f" ] || return 0

		if [ "${f##*/}" = ".provides.sh" ]; then
			if [ -n "$FIND_SHELL" ]; then
				local r
				r="$(@RPMCONFIGDIR@/shell.prov "$f")" || return 1
				[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
			fi
			return 0
		fi
	fi

	# Ignore symlinks for non-PAM scripts.
	[ ! -L "$f" ] || return 0

	if [ -z "${t##perl script text*}" -o -z "${t##Perl5 module source text}" -o -z "${f%%*.p[lmh]}" ]; then
		if [ -n "$FIND_PERL" ]; then
			[ -z "$LIST_PERL" ] && LIST_PERL="$f" || LIST_PERL="$LIST_PERL
$f"
		fi
	fi
}

FindPerlProvs()
{
	[ -n "$LIST_PERL" ] || return 0

	local r
	r="$(printf %s\\n "$LIST_PERL" |@RPMCONFIGDIR@/perl.prov)" || return 1
	[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
}

DEF_RPM_FINDPROV_LIB_PATH='/lib:/usr/lib:/usr/X11R6/lib'
: ${RPM_FINDPROV_LIB_PATH:=$DEF_RPM_FINDPROV_LIB_PATH}

lookup_path()
{
	local d dir path found=
	dir="$1" && shift
	path="$1" && shift
	for d in $(printf %s "$path" |tr : ' '); do
		[ "$d" = "$dir" ] || continue
		found="$d"
		break
	done
	[ -n "$found" ] && return 0 || return 1
}

# Note this works for both a.out and ELF executables.
FindLibProvs()
{
	[ -n "$FIND_LIBS" ] || return 0

	local f dir name dump
	f="$1"
	dir="${fname%/*}"
	[ -n "$dir" ] || return 0
	name="${fname##*/}"
	[ -n "$name" ] || return 0

	lookup_path "$dir" "$RPM_FINDPROV_LIB_PATH" || return 0

	if dump="$(objdump -p "$f")"; then
		local soname
		soname="$(printf %s\\n "$dump" |awk '/SONAME/ {print $2}')" || return 1
		if [ -n "$soname" ]; then
			while :; do
				# For libraries with soname, ignore all but files named as soname.
				[ "$soname" = "$name" ] || break

				# Treat symlinks specially.
				if [ -L "$f" ]; then
					local real realpath realdir
					realpath=$(readlink -fv "$f") || break
					real="${realpath#$real_buildroot}"
					# Ignore symlinks leading out of buildroot.
					[ "$real" != "$realpath" ] || break
					realdir="${real%/*}"
					# Ignore symlinks to shorter locations.
					[ "${#dir}" -le "${#realdir}" ] || break
				fi
				
				# Check for non-default path.
				local nondefdir=
				lookup_path "$dir" "$DEF_RPM_FINDPROV_LIB_PATH" || nondefdir="$dir"

				# Output soname.
				printf %s\\n "$soname"
				[ -z "$nondefdir" ] || printf "$nondefdir/%s\\n" "$soname"

				# Output version definitions.
	    			printf %s\\n "$dump" | awk "-vsoname=$soname" "-vnondefdir=$nondefdir" '
					BEGIN {start=0;}
					/^Version definitions:$/ {start=1;}
					/^[0-9]/ && (start==1) && ($4!="") && ($4!=soname) {
						printf("%s(%s)\n",soname,$4)
						if (nondefdir!="")
							printf("%s/%s(%s)\n",nondefdir,soname,$4)
					}
					/^$/ {start=0;}
				' || return 1

				break
			done
		else
			# Ignore symlinks for libraries without soname.
			[ -L "$f" ] || printf %s\\n "${f##*/}"
		fi
	fi
}

: ${RPM_FINDPROV_TOPDIR:=}
: ${RPM_FINDPROV_SKIPLIST:=}

while IFS= read -r f; do
	fname="${f#$RPM_BUILD_ROOT}"
	fname="${fname#.}"

	if [ -n "$RPM_FINDPROV_TOPDIR" ] && [ -z "${fname%%$RPM_FINDPROV_TOPDIR/*}" ]; then
		continue;
	fi
	if [ -n "$RPM_FINDPROV_SKIPLIST" ]; then
		for skip in $RPM_FINDPROV_SKIPLIST; do
			if [ -z "${fname##$skip}" ]; then
				continue 2
			fi
		done
	fi
	# Find out file type (dereference symlinks).
	if t="$(file -bL "$f")"; then
		if [ -z "${t##* text*}" ]; then
			ListScriptProvs "$f" "$t"
		elif [ -z "${t##* shared object*}" ]; then
			r="$(FindLibProvs "$f")"
			[ -z "$FOUND_PROVS" ] && FOUND_PROVS="$r" || FOUND_PROVS="$FOUND_PROVS
$r"
		fi
	else
		echo "Not found: $f" >&2
	fi
done

# Find provides in listed perl scripts, if any
FindPerlProvs

# Finally sort and print them.
printf %s "$FOUND_PROVS" |LC_COLLATE=C sort -u
