#!/bin/sh -efu
#
# Copyright (C) 2002-2003  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2007       Alexey Tourbin <at@altlinux.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

. @RPMCONFIGDIR@/functions

FindByPath()
{
	# Dependence name starts with `/'.
	local f="$1" rep="$2" package; shift 2 || return

	# Does it start with buildroot?
	if [ -n "${RPM_BUILD_ROOT-}" ] && [ -z "${rep##$RPM_BUILD_ROOT*}" ]; then
		Info "$f: invalid dependence: $rep"
		return 1
	fi

	# Does it belong to buildroot?
	if [ -n "${RPM_BUILD_ROOT-}" ] && [ -e "$RPM_BUILD_ROOT$rep" ]; then
		Verbose "$f: $rep -> \$RPM_BUILD_ROOT$rep (skip)"
		return
	fi

	# Is it an alternative?
	if readlink "$rep" |grep -qs '^/etc/alternatives/'; then
		Verbose "$f: $rep -> $rep (alternative)"
		printf %s\\n "$rep"
		return
	fi

	# Check for pkg contents complete index and pkg binary index.
	local idx
	for idx in "${RPM_PKG_CONTENTS_INDEX_ALL-}" "${RPM_PKG_CONTENTS_INDEX_BIN-}"; do
		[ -n "$idx" ] && [ -s "$idx" ] && [ -r "$idx" ] || continue
		package="$(awk -v "f=$rep" '($1 == f) {print $2}' "$idx" |sort -u)"
		local n="$(IFS=$'\n'; set -- $package; echo $#)"
		if [ "$n" = 1 ]; then
			Verbose "$f: $rep -> $package (via content index)"
			printf %s\\n "$package"
			return
		elif [ "$n" -gt 1 ]; then
			Info "$f: $rep indexed by:$(echo '' $package)"
			Verbose "$f: $rep -> $rep (raw, ambiguous, via content index)"
			printf %s\\n "$rep"
			return
		fi
	done

	# Check package database.
	if package="$(rpmquery --whatprovides --queryformat='%{NAME}\n' -- "$rep")"; then
		package="$(printf %s "$package" |LC_COLLATE=C sort -u)"
		local n="$(IFS=$'\n'; set -- $package; echo $#)"
		if [ "$n" = 1 ]; then
			Verbose "$f: $rep -> $package (via rpmdb)"
			printf %s\\n "$package"
			return
		elif [ "$n" -gt 1 ]; then
			Info "$f: $rep provided by:$(echo '' $package)"
			Verbose "$f: $rep -> $rep (raw, ambiguous, via rpmdb)"
			printf %s\\n "$rep"
			return
		fi
	fi

	# Not found; output raw dependence.
	Verbose "$f: $rep -> $rep (raw, not found)"
	printf %s\\n "$rep"
}

FindByName()
{
	local f="$1" r="$2" rep package; shift 2 || return

	# Check buildroot first.
	if [ -n "${RPM_BUILD_ROOT-}" ]; then
		local RPATH
		RPATH="$(printf %s "$PATH" |sed -e "s|[^:]\+|$RPM_BUILD_ROOT&|g")"
		if rep="$(PATH="$RPATH" /usr/bin/which -- "$r" 2>/dev/null)"; then
			Verbose "$f: $r -> \$RPM_BUILD_ROOT${rep#$RPM_BUILD_ROOT} (skip)"
			return
		fi
	fi

	# Check for pkg contents binary index.
	if [ -n "${RPM_PKG_CONTENTS_INDEX_BIN-}" ] && [ -s "$RPM_PKG_CONTENTS_INDEX_BIN" ] && [ -r "$RPM_PKG_CONTENTS_INDEX_BIN" ]; then
		for location in /sbin /usr/sbin /bin /usr/bin /usr/X11R6/bin; do
			package="$(awk -v "f=$location/$r" '{if ($1 == f) {print $2; exit}}' "$RPM_PKG_CONTENTS_INDEX_BIN")"
			if [ -n "$package" ]; then
				Verbose "$r -> $location/$r -> $package (via content index)"
				printf %s\\n "$package"
				return
			fi
		done
	fi

	# Lookup in the host system.
	if rep="$(/usr/bin/which --all --skip-tilde -- "$r" 2>/dev/null)"; then
		local n="$(IFS=$'\n'; set -- $rep; echo $#)"
		if [ "$n" -gt 1 ]; then
			n="$(IFS=$'\n'; for f in $rep; do readlink -vm "$f"; done |sort -u |wc -l)"
			[ "$n" = 1 ] || Info "$f: which $r:$(echo '' $rep)"
			rep="$(IFS=$'\n'; set -- $rep; printf %s "$1")"
		fi
		if [ -n "$rep" ]; then
			Verbose "$f: $r -> $rep -> ... (via which)"
			FindByPath "$f" "$rep"
			return
		fi
	fi

	# Not found.
	Verbose "$f: $r not found (skip)"
}

FindPackage()
{
	local f="$1" r; shift || return

	for r; do
		[ -n "$r" ] || continue
		if [ -z "${r##/*}" ]; then
			FindByPath "$f" "$r"
		else
			FindByName "$f" "$r"
		fi
	done
}
