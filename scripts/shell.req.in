#!/bin/sh -efu
#
# Copyright (C) 2000,2003  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2007       Alexey Tourbin <at@altlinux.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

. @RPMCONFIGDIR@/functions
. @RPMCONFIGDIR@/find-package

workdir=
clean_workdir()
{
	local rc=$?
	trap - EXIT
	[ -z "$workdir" ] || rm -rf "$workdir"
	exit $rc
}

init_workdir()
{
	[ -z "$workdir" ] || return 0
	workdir=$(mktemp -dt "$PROG".XXXXXXXX)
	trap clean_workdir EXIT HUP INT QUIT PIPE TERM
	: >"$workdir"/req
	: >"$workdir"/prov
}

ShellReq()
{
	local f="$1"; shift

	local t sh
	t=$(file -bL "$f") || Fatal "${t:-$f: file type not available}"
	case "$t" in
		*"Bourne-Again shell script text"*)
			sh=/bin/bash ;;
		*" bash script text"*)
			sh=/bin/bash ;;
		*)
			sh=/bin/sh ;;
	esac
	$sh --rpm-requires </dev/null >/dev/null ||
		Fatal "$sh interpreter does not support --rpm-requires feature"

	local reqs line1
	if ! reqs="$($sh --rpm-requires "$f")"; then
		# sh --rpm-requires failed, and stderr is already there.
		# We are almost dead.  The last chance to escape is to see
		# if the shell is used only to re-exec another interpreter, e.g.
		#	exec tclsh "$0" "$@"
		if line1=$(egrep -m1 -v '^[[:space:]]*(#|$)' "$f"); then
			set -- $line1
			if [ $# -gt 1 ] && [ "$1" = exec ]; then
				Info "$f is $2 script!"
				# We do no more than shebang.req does.  If the script
				# is not executable, shebang.req.files must have been
				# already issued "executable not executable" warning.
				if [ -x "$f" ]; then
					FindPackage "$f" "$2"
				fi
				return 0
			fi
		fi
		Fatal "$f: $sh --rpm-requires failed"
	fi

	[ -n "$reqs" ] || return 0

	# This function is a "closure": parent variables are available without
	# explicit argument passing.  I checked that it works at least with some
	# modern shells.  Why I ever need a separate function is because my $EDITOR
	# is not as perfect as to provide decent syntax highlight for subshells.
	CleanupRpmRequires()
	{
		printf '%s\n' "$reqs" |
		# I do not use 'read -r' here deliberately:
		# I want to transform e.g. 'executable(\ls)' -> 'executable(ls)'
		while read line; do
			# NB: grep and sed are expensive here.
			case "$line" in
				# Basic sanity check for --rpm-requires output.
				# Better command/path validation is performed in FindPackage.
				'executable('*[A-Za-z0-9]*')' | 'function('*[A-Za-z0-9]*')' ) ;;
				*) Info "$f: invalid $sh --rpm-requires output: $line"; continue ;;
			esac
			set -- $(IFS="($IFS)"; echo $line)
			case $# in
				2) ;;
				*) Info "$f: invalid $sh --rpm-requires output: $line"; continue ;;
			esac
			case "$(type -t -- "$2")" in
				alias|keyword|function|builtin) continue ;;
				*) printf '%s\t%s\n' "$1" "$2" ;;
			esac
		done
	}
	reqs=$(CleanupRpmRequires)

	# Self-requires elimination: first pass.
	# Consider e.g. /etc/rc.d/init.d/functions has both
	# executable(failure) and function(failure).
	# This means that failure() is used before being defined.
	# This is okay since it is actually used in another function.
	# We want to keep only the function(failure).
	reqs=$(printf '%s\n' "$reqs" |sort -k1,1r |LC_COLLATE=C sort -u -k2)

	init_workdir

	printf %s "$reqs" |
	while read -r t r; do
		case "$t" in
			executable) printf '%s\t%s\n' "$f" "$r" >>"$workdir"/req ;;
			function) printf '%s\t%s\n' "$f" "$r" >>"$workdir"/prov ;;
		esac
	done
}

ShellReqEND()
{
	[ -n "$workdir" ] || return 0
	local f r
	while IFS=$'\t' read -r f r; do
		local self_req=
		while IFS=$'\t' read -r f2 r2; do
			if [ "$r" = "$r2" ]; then
				Verbose "$f: $r() is possibly defined in $f2"
				self_req=1
			fi
		done <"$workdir"/prov
		[ -z "$self_req" ] || continue
		local dname
		dname=${f#${RPM_BUILD_ROOT-}}
		dname=${dname%/*}
		if grep -qs -Fx -- "$r" "${RPM_BUILD_ROOT-}$dname/.provides.sh"; then
			printf %s\\n "$dname($r)"
		elif grep -qs -Fx -- "$r" "$dname/.provides.sh"; then
			printf %s\\n "$dname($r)"
		else
			FindPackage "$f" "$r"
		fi
	done <"$workdir"/req
}

ArgvFileAction ShellReq "$@"
ShellReqEND
